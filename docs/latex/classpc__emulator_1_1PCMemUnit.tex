\hypertarget{classpc__emulator_1_1PCMemUnit}{}\section{pc\+\_\+emulator\+:\+:P\+C\+Mem\+Unit Class Reference}
\label{classpc__emulator_1_1PCMemUnit}\index{pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit@{pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit}}


Describes a memory unit and provides api to access it.  




{\ttfamily \#include $<$pc\+\_\+mem\+\_\+unit.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classpc__emulator_1_1PCMemUnit_a13340ee696d0d3f5b6858791b64a9de5}{P\+C\+Mem\+Unit} ()\hypertarget{classpc__emulator_1_1PCMemUnit_a13340ee696d0d3f5b6858791b64a9de5}{}\label{classpc__emulator_1_1PCMemUnit_a13340ee696d0d3f5b6858791b64a9de5}

\begin{DoxyCompactList}\small\item\em Constructor. \end{DoxyCompactList}\item 
void \hyperlink{classpc__emulator_1_1PCMemUnit_ab061a73c8934d7a7796db28f26c32989}{Allocate\+Static\+Memory} (int Size\+Bytes)\hypertarget{classpc__emulator_1_1PCMemUnit_ab061a73c8934d7a7796db28f26c32989}{}\label{classpc__emulator_1_1PCMemUnit_ab061a73c8934d7a7796db28f26c32989}

\begin{DoxyCompactList}\small\item\em Allocate ordinary memory with specified size. \end{DoxyCompactList}\item 
void \hyperlink{classpc__emulator_1_1PCMemUnit_a35f27d5bb1922e0611211c5031ab9d83}{Allocate\+Shared\+Memory} (int Size\+Bytes, string mmap\+\_\+file\+\_\+path, string lock\+\_\+name)
\begin{DoxyCompactList}\small\item\em Allocate M\+M\+AP\textquotesingle{}ed memory. \end{DoxyCompactList}\item 
std\+::shared\+\_\+ptr$<$ char $>$ \hyperlink{classpc__emulator_1_1PCMemUnit_af562a3bf682d124185d12ccc476d4aa5}{Get\+Storage\+Location} ()\hypertarget{classpc__emulator_1_1PCMemUnit_af562a3bf682d124185d12ccc476d4aa5}{}\label{classpc__emulator_1_1PCMemUnit_af562a3bf682d124185d12ccc476d4aa5}

\begin{DoxyCompactList}\small\item\em Returns a pointer to the base storage location. \end{DoxyCompactList}\item 
bool \hyperlink{classpc__emulator_1_1PCMemUnit_af0169bf026478f72e04c62f92979a6d6}{Is\+Initialized} ()\hypertarget{classpc__emulator_1_1PCMemUnit_af0169bf026478f72e04c62f92979a6d6}{}\label{classpc__emulator_1_1PCMemUnit_af0169bf026478f72e04c62f92979a6d6}

\begin{DoxyCompactList}\small\item\em Returns true if memory unit is initialized. \end{DoxyCompactList}\item 
int \hyperlink{classpc__emulator_1_1PCMemUnit_aa4db563b6e4e2d642d322bbc4167f006}{Get\+Mem\+Unit\+Size} ()\hypertarget{classpc__emulator_1_1PCMemUnit_aa4db563b6e4e2d642d322bbc4167f006}{}\label{classpc__emulator_1_1PCMemUnit_aa4db563b6e4e2d642d322bbc4167f006}

\begin{DoxyCompactList}\small\item\em Returns the size of the memory unit. \end{DoxyCompactList}\item 
void \hyperlink{classpc__emulator_1_1PCMemUnit_a9aa9aca9f68e329e45b746247ddc0b39}{Set\+Mem\+Unit\+Location} (\hyperlink{classpc__emulator_1_1PCMemUnit}{P\+C\+Mem\+Unit} $\ast$From)
\begin{DoxyCompactList}\small\item\em Assigns memory location from another memory unit to this one. \end{DoxyCompactList}\item 
void $\ast$ \hyperlink{classpc__emulator_1_1PCMemUnit_a45ccc33e0c33a7680dd53f1e7580f03d}{Get\+Pointer\+To\+Memory} (int Offset)\hypertarget{classpc__emulator_1_1PCMemUnit_a45ccc33e0c33a7680dd53f1e7580f03d}{}\label{classpc__emulator_1_1PCMemUnit_a45ccc33e0c33a7680dd53f1e7580f03d}

\begin{DoxyCompactList}\small\item\em Returns a pointer to memory location with specified offset. \end{DoxyCompactList}\item 
void \hyperlink{classpc__emulator_1_1PCMemUnit_a47afeb8fd963e86394dab636ec525346}{Copy\+From\+Mem\+Unit} (\hyperlink{classpc__emulator_1_1PCMemUnit}{P\+C\+Mem\+Unit} $\ast$From, int From\+Start\+Offset, int Copy\+Size\+Bytes, int To\+Start\+Offset)
\begin{DoxyCompactList}\small\item\em Copies data from another memory unit. \end{DoxyCompactList}\item 
void \hyperlink{classpc__emulator_1_1PCMemUnit_ab7550cf98c33fc7577bd609ce350a739}{Reallocate\+Static\+Memory} (int Mem\+Size)\hypertarget{classpc__emulator_1_1PCMemUnit_ab7550cf98c33fc7577bd609ce350a739}{}\label{classpc__emulator_1_1PCMemUnit_ab7550cf98c33fc7577bd609ce350a739}

\begin{DoxyCompactList}\small\item\em Frees memory already allocated and reallocates it. \end{DoxyCompactList}\item 
void \hyperlink{classpc__emulator_1_1PCMemUnit_acd998eb1872e19b78403f34cc3265781}{Cleanup} ()\hypertarget{classpc__emulator_1_1PCMemUnit_acd998eb1872e19b78403f34cc3265781}{}\label{classpc__emulator_1_1PCMemUnit_acd998eb1872e19b78403f34cc3265781}

\begin{DoxyCompactList}\small\item\em Calls Mun\+Map and destroyes the created semaphore. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classpc__emulator_1_1PCMemUnit_abfb2a465dc75c79a392953fa9a143f28}{\+\_\+\+\_\+is\+Mem\+Controller\+Active}
\item 
sem\+\_\+t $\ast$ \hyperlink{classpc__emulator_1_1PCMemUnit_a77c288dd119a5ecd08bc793ed6a9b4cf}{\+\_\+\+\_\+sem\+\_\+lock}
\item 
string \hyperlink{classpc__emulator_1_1PCMemUnit_afa96f416f54665c3363aa4b110a6bcd9}{\+\_\+\+\_\+sem\+\_\+name}
\item 
string \hyperlink{classpc__emulator_1_1PCMemUnit_a0fcd708b1a7ee5ec5f6ba24d4b24a324}{\+\_\+\+\_\+mmap\+\_\+file\+\_\+name}
\end{DoxyCompactItemize}
\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classpc__emulator_1_1PCMemUnit_ab8a962fcf9bb78aad0b85e3ff2209096}{operator==} (const \hyperlink{classpc__emulator_1_1PCMemUnit}{P\+C\+Mem\+Unit} \&Mem\+Unit1, const \hyperlink{classpc__emulator_1_1PCMemUnit}{P\+C\+Mem\+Unit} \&Mem\+Unit2)
\begin{DoxyCompactList}\small\item\em Checks if two Mem\+Units are equal. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Describes a memory unit and provides api to access it. 

\subsection{Member Function Documentation}
\index{pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit@{pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit}!Allocate\+Shared\+Memory@{Allocate\+Shared\+Memory}}
\index{Allocate\+Shared\+Memory@{Allocate\+Shared\+Memory}!pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit@{pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit}}
\subsubsection[{\texorpdfstring{Allocate\+Shared\+Memory(int Size\+Bytes, string mmap\+\_\+file\+\_\+path, string lock\+\_\+name)}{AllocateSharedMemory(int SizeBytes, string mmap_file_path, string lock_name)}}]{\setlength{\rightskip}{0pt plus 5cm}void pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit\+::\+Allocate\+Shared\+Memory (
\begin{DoxyParamCaption}
\item[{int}]{Size\+Bytes, }
\item[{string}]{mmap\+\_\+file\+\_\+path, }
\item[{string}]{lock\+\_\+name}
\end{DoxyParamCaption}
)}\hypertarget{classpc__emulator_1_1PCMemUnit_a35f27d5bb1922e0611211c5031ab9d83}{}\label{classpc__emulator_1_1PCMemUnit_a35f27d5bb1922e0611211c5031ab9d83}


Allocate M\+M\+AP\textquotesingle{}ed memory. 


\begin{DoxyParams}{Parameters}
{\em Size\+Bytes} & Size of memory to be allocated in bytes \\
\hline
{\em mmap\+\_\+file\+\_\+path} & Absolute path to mmap file location \\
\hline
{\em lock\+\_\+name} & Name assigned to semaphore \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\+\_\+\+\_\+\+Initialized is set to true 
\end{DoxySeeAlso}
\index{pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit@{pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit}!Copy\+From\+Mem\+Unit@{Copy\+From\+Mem\+Unit}}
\index{Copy\+From\+Mem\+Unit@{Copy\+From\+Mem\+Unit}!pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit@{pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit}}
\subsubsection[{\texorpdfstring{Copy\+From\+Mem\+Unit(\+P\+C\+Mem\+Unit $\ast$\+From, int From\+Start\+Offset, int Copy\+Size\+Bytes, int To\+Start\+Offset)}{CopyFromMemUnit(PCMemUnit *From, int FromStartOffset, int CopySizeBytes, int ToStartOffset)}}]{\setlength{\rightskip}{0pt plus 5cm}void pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit\+::\+Copy\+From\+Mem\+Unit (
\begin{DoxyParamCaption}
\item[{{\bf P\+C\+Mem\+Unit} $\ast$}]{From, }
\item[{int}]{From\+Start\+Offset, }
\item[{int}]{Copy\+Size\+Bytes, }
\item[{int}]{To\+Start\+Offset}
\end{DoxyParamCaption}
)}\hypertarget{classpc__emulator_1_1PCMemUnit_a47afeb8fd963e86394dab636ec525346}{}\label{classpc__emulator_1_1PCMemUnit_a47afeb8fd963e86394dab636ec525346}


Copies data from another memory unit. 

Copies data starting from the specified \char`\"{}\+From\+Start\+Offset\char`\"{} and stores it to locations starting from the specified \char`\"{}\+To\+Start\+Offset\char`\"{}


\begin{DoxyParams}{Parameters}
{\em From} & Mem\+Unit to copy from \\
\hline
{\em From\+Start\+Offset} & Offset added to From\textquotesingle{}s Mem\+Unit \\
\hline
{\em Copy\+Size\+Bytes} & Amount of data to copy \\
\hline
{\em To\+Start\+Offset} & Offset added to this Mem\+Unit \\
\hline
\end{DoxyParams}
\index{pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit@{pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit}!Set\+Mem\+Unit\+Location@{Set\+Mem\+Unit\+Location}}
\index{Set\+Mem\+Unit\+Location@{Set\+Mem\+Unit\+Location}!pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit@{pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit}}
\subsubsection[{\texorpdfstring{Set\+Mem\+Unit\+Location(\+P\+C\+Mem\+Unit $\ast$\+From)}{SetMemUnitLocation(PCMemUnit *From)}}]{\setlength{\rightskip}{0pt plus 5cm}void pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit\+::\+Set\+Mem\+Unit\+Location (
\begin{DoxyParamCaption}
\item[{{\bf P\+C\+Mem\+Unit} $\ast$}]{From}
\end{DoxyParamCaption}
)}\hypertarget{classpc__emulator_1_1PCMemUnit_a9aa9aca9f68e329e45b746247ddc0b39}{}\label{classpc__emulator_1_1PCMemUnit_a9aa9aca9f68e329e45b746247ddc0b39}


Assigns memory location from another memory unit to this one. 


\begin{DoxyParams}{Parameters}
{\em From} & base storage location of this unit is made to point to the base storage location of \char`\"{}\+From\char`\"{} \\
\hline
\end{DoxyParams}


\subsection{Friends And Related Function Documentation}
\index{pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit@{pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit}!operator==@{operator==}}
\index{operator==@{operator==}!pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit@{pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit}}
\subsubsection[{\texorpdfstring{operator==}{operator==}}]{\setlength{\rightskip}{0pt plus 5cm}bool operator== (
\begin{DoxyParamCaption}
\item[{const {\bf P\+C\+Mem\+Unit} \&}]{Mem\+Unit1, }
\item[{const {\bf P\+C\+Mem\+Unit} \&}]{Mem\+Unit2}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [friend]}}\hypertarget{classpc__emulator_1_1PCMemUnit_ab8a962fcf9bb78aad0b85e3ff2209096}{}\label{classpc__emulator_1_1PCMemUnit_ab8a962fcf9bb78aad0b85e3ff2209096}


Checks if two Mem\+Units are equal. 


\begin{DoxyParams}{Parameters}
{\em Mem\+Unit1} & Memory Unit 1 \\
\hline
{\em Mem\+Unit2} & Memory Unit 2 \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true iff both have the same base storage location 
\end{DoxyReturn}


\subsection{Member Data Documentation}
\index{pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit@{pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit}!\+\_\+\+\_\+is\+Mem\+Controller\+Active@{\+\_\+\+\_\+is\+Mem\+Controller\+Active}}
\index{\+\_\+\+\_\+is\+Mem\+Controller\+Active@{\+\_\+\+\_\+is\+Mem\+Controller\+Active}!pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit@{pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit}}
\subsubsection[{\texorpdfstring{\+\_\+\+\_\+is\+Mem\+Controller\+Active}{__isMemControllerActive}}]{\setlength{\rightskip}{0pt plus 5cm}bool pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit\+::\+\_\+\+\_\+is\+Mem\+Controller\+Active}\hypertarget{classpc__emulator_1_1PCMemUnit_abfb2a465dc75c79a392953fa9a143f28}{}\label{classpc__emulator_1_1PCMemUnit_abfb2a465dc75c79a392953fa9a143f28}
Set to true iff M\+M\+AP\textquotesingle{}ed memory is allocated \index{pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit@{pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit}!\+\_\+\+\_\+mmap\+\_\+file\+\_\+name@{\+\_\+\+\_\+mmap\+\_\+file\+\_\+name}}
\index{\+\_\+\+\_\+mmap\+\_\+file\+\_\+name@{\+\_\+\+\_\+mmap\+\_\+file\+\_\+name}!pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit@{pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit}}
\subsubsection[{\texorpdfstring{\+\_\+\+\_\+mmap\+\_\+file\+\_\+name}{__mmap_file_name}}]{\setlength{\rightskip}{0pt plus 5cm}string pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit\+::\+\_\+\+\_\+mmap\+\_\+file\+\_\+name}\hypertarget{classpc__emulator_1_1PCMemUnit_a0fcd708b1a7ee5ec5f6ba24d4b24a324}{}\label{classpc__emulator_1_1PCMemUnit_a0fcd708b1a7ee5ec5f6ba24d4b24a324}
Name of the mmaped file \index{pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit@{pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit}!\+\_\+\+\_\+sem\+\_\+lock@{\+\_\+\+\_\+sem\+\_\+lock}}
\index{\+\_\+\+\_\+sem\+\_\+lock@{\+\_\+\+\_\+sem\+\_\+lock}!pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit@{pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit}}
\subsubsection[{\texorpdfstring{\+\_\+\+\_\+sem\+\_\+lock}{__sem_lock}}]{\setlength{\rightskip}{0pt plus 5cm}sem\+\_\+t$\ast$ pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit\+::\+\_\+\+\_\+sem\+\_\+lock}\hypertarget{classpc__emulator_1_1PCMemUnit_a77c288dd119a5ecd08bc793ed6a9b4cf}{}\label{classpc__emulator_1_1PCMemUnit_a77c288dd119a5ecd08bc793ed6a9b4cf}
A semaphore lock used to access M\+M\+AP\textquotesingle{}ed memory \index{pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit@{pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit}!\+\_\+\+\_\+sem\+\_\+name@{\+\_\+\+\_\+sem\+\_\+name}}
\index{\+\_\+\+\_\+sem\+\_\+name@{\+\_\+\+\_\+sem\+\_\+name}!pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit@{pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit}}
\subsubsection[{\texorpdfstring{\+\_\+\+\_\+sem\+\_\+name}{__sem_name}}]{\setlength{\rightskip}{0pt plus 5cm}string pc\+\_\+emulator\+::\+P\+C\+Mem\+Unit\+::\+\_\+\+\_\+sem\+\_\+name}\hypertarget{classpc__emulator_1_1PCMemUnit_afa96f416f54665c3363aa4b110a6bcd9}{}\label{classpc__emulator_1_1PCMemUnit_afa96f416f54665c3363aa4b110a6bcd9}
Name of the semaphore 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/pc\+\_\+emulator/include/pc\+\_\+mem\+\_\+unit.\+h\end{DoxyCompactItemize}
